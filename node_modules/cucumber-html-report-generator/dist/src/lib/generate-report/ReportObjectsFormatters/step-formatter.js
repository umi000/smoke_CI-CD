"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.StepFormatter = void 0;
const CommonFunctions = __importStar(require("../../common-functions/common-functions"));
const Models = __importStar(require("../../models/models"));
class StepFormatter {
    parseStep(step) {
        let localStep = step;
        localStep = this.initializeStep(localStep);
        localStep = this.formatStepEmbeddings(localStep);
        if (typeof step.rows !== 'undefined' && step.rows.length) {
            step.rowsCells = this.formatRows(step.rows);
        }
        step.argumentsCells = this.formatRows(step.arguments?.[0]?.rows);
        this.setColorAndIcon(step);
        return localStep;
    }
    formatStepEmbeddings(step) {
        if (step.embeddings.length) {
            step.embeddings.forEach((embedding, embeddingIndex) => {
                let embeddingType = typeof embedding.mime_type === 'undefined' ? embedding.media?.type : embedding.mime_type;
                let embeddingData = embedding.data;
                switch (embeddingType) {
                    case 'application/json':
                        try {
                            embeddingData = JSON.stringify(JSON.parse(embeddingData), undefined, 2);
                        }
                        catch (error) {
                            embeddingData = error.message;
                        }
                        step.json = step.json.concat([embeddingData]);
                        break;
                    case 'text/html':
                        step.html = step.html.concat([CommonFunctions.isBase64(embeddingData) ? Buffer.from(embeddingData, 'base64').toString('utf-8') : embeddingData]);
                        break;
                    case 'text/plain':
                        step.text = (step.text ? step.text : []).concat([
                            CommonFunctions.isBase64(embeddingData) ? CommonFunctions.escapeHTML(Buffer.from(embeddingData, 'binary').toString('base64')) : CommonFunctions.escapeHTML(embeddingData)
                        ]);
                        break;
                    case 'image/png':
                        embeddingType.split(':');
                        step.image = step.image.concat([`data:image/png;base64,${embeddingData}`]);
                        step.embeddings[embeddingIndex] = {};
                        break;
                    case 'audio/ogg':
                        step.audio = step.audio.concat([`data:audio/mpeg;base64,${embeddingData}`]);
                        step.embeddings[embeddingIndex] = {};
                        break;
                    case 'video/ogg':
                        step.video = step.video.concat([`data:video/mpeg;base64,${embeddingData}`]);
                        step.embeddings[embeddingIndex] = {};
                        break;
                    default:
                        embeddingType = 'text/plain';
                        if (embedding.mime_type) {
                            embeddingType = embedding.mime_type;
                        }
                        else if (embedding.media?.type) {
                            embeddingType = embedding.media.type;
                        }
                        step.attachments.push({
                            data: `data:${embeddingType};base64,${embedding.data}`,
                            type: embeddingType
                        });
                }
                step.embeddings[embeddingIndex] = {};
            });
        }
        return step;
    }
    formatRows(rows) {
        let rowsTemp = '';
        if (typeof rows !== 'undefined' && rows.length) {
            rowsTemp = '<table class=\'table-bordered table-dark ms-4\'>';
            rows.forEach((row, rowIndex) => {
                rowsTemp += '<tr\\>';
                row.cells.forEach((cell) => {
                    if (rowIndex === 0) {
                        rowsTemp += `<td class=bg-primary> ${cell} </td>`;
                    }
                    else {
                        rowsTemp += `<td> ${cell} </td>`;
                    }
                });
                rowsTemp += '</tr>';
            });
            rowsTemp = `${rowsTemp} </table>`;
        }
        return rowsTemp;
    }
    setColorAndIcon(step) {
        switch (step.result.status) {
            case Models.Status.passed:
                step.result.color = ' passed-color';
                step.result.icon = 'fa fa-check-circle fa-1x';
                step.result.title = 'Step passed';
                break;
            case Models.Status.failed:
                step.result.color = ' failed-color';
                step.result.icon = ' fa fa-exclamation-circle fa-1x ';
                step.result.title = 'Step failed';
                break;
            case Models.Status.ambiguous:
                step.result.color = 'ambiguous-color';
                step.result.icon = ' fas fa-bolt fa-1x ';
                step.result.title = 'Step has double step implementation and failed because of that';
                break;
            case Models.Status.pending:
                step.result.color = 'pending-color';
                step.result.icon = ' fa fa-minus-circle fa-1x ';
                step.result.title = 'Step is pending';
                break;
            case Models.Status.skipped:
                step.result.color = 'skipped-color';
                step.result.icon = ' fas fa-arrow-circle-right fa-1x ';
                step.result.title = 'Step is skipped';
                break;
            case Models.Status.undefined:
                step.result.color = 'undefined-color';
                step.result.icon = ' fa fa-question-circle fa-1x ';
                step.result.title = 'Step passed';
                break;
            // No default
        }
    }
    initializeStep(step) {
        step.audio = [];
        step.attachments = [];
        step.arguments = typeof step.arguments === 'undefined' ? [] : step.arguments;
        step.embeddings = typeof step.embeddings === 'undefined' ? [] : step.embeddings;
        step.examples = [];
        step.html = [];
        step.json = [];
        step.id = '';
        step.line = typeof step.line === 'undefined' ? -1 : step.line;
        step.image = [];
        step.result.duration = typeof step.result.duration === 'undefined' ? 0 : step.result.duration;
        step.result.durationHHMMSS = CommonFunctions.convertTimeFromNanoSecondsToHHMMSS(step.result.duration);
        step.rows = typeof step.rows === 'undefined' ? [] : step.rows;
        step.text = null;
        step.output = typeof step.output === 'undefined' ? [] : step.output;
        step.video = [];
        if (step.match) {
            step.match.arguments = typeof step.match.arguments === 'undefined' ? [] : step.match.arguments;
            step.match.location = '';
        }
        return step;
    }
}
exports.StepFormatter = StepFormatter;
//# sourceMappingURL=step-formatter.js.map